//---------------------------------------------------------------------------------------------
//	Hello world test code for SIFP (c) 2023-... zpekic@hotmail.com
//  Compile with https://github.com/zpekic/MicroCodeCompiler
//---------------------------------------------------------------------------------------------
// Test code to load into internal ROM of SIFP microcomputer
// Full description: 
// https://hackaday.io/project/173996-sifp-single-instruction-format-processor
//---------------------------------------------------------------------------------------------
			.code 12, 16, *_code.mif, *_code.cgf, *_code.coe, cpu:*_code.vhd, *_code.hex, *_code.bin, 2;
			.symbol 12, 256, *_symbol.mif, *_symbol.cgf, *_symbol.coe, sym:*_symbol.vhd, *_symbol.hex, *_symbol.bin, 32;

#include "sifp.mcc";
#include "sifp_sys.mcc";

//	---------------------------------------------------------------------------
			.org 0;
//	Execution starts at location 0
//	---------------------------------------------------------------------------
			INTOFF;		// pro-forma, IE flag is cleared by reset
			TRACEOFF;	// pro-forma, TE flag is cleared by reset
			JA Init;
			
//	---------------------------------------------------------------------------
//	interrupt handling routine
//	---------------------------------------------------------------------------
			.org 8;
IntHandler:	PUSHA;
			PUSHX;
			PUSHY;

			TRACEON;
			
			JSR GetOldCrsXY;
			PUSHY;
			PUSHX;
			JSR GetRowBase;
			LDA, M[Y+X];	// get character from VGA RAM
			ANDI 0xFF7F;	// revert to original
			STA, M[Y+X];
			JSR GetCursorXY;
			CPX, M[POP];	// new X - old X
			CPY, M[POP];	// new Y - old Y
			IF_X_NE_THEN NoFlip;
CheckY:		IF_Y_EQ_THEN Flip;
NoFlip:		JSR SetOldCrsXY;
			JR IntExit;
			
Flip:		JSR GetCursorXY;
			JSR GetRowBase;
			LDA, M[Y+X];	// get character from VGA RAM
			XORI 0x0080;	// reverse back and forth
			STA, M[Y+X];
			
IntExit:	POPY;
			POPX;
			POPA;
			RTF;	// F and P were saved when entering the interrupt routine
//	---------------------------------------------------------------------------			

Init:		JSR VGA_Init;

			JSR UART_Init;

			//TRACEON;
			INTON;
PrintLoop:	JSR UART_GetChr;
PrintLoop1:	JSR PrintChr;
			PUSHA;
			XORI ETX;
			IF_A_EQ_THEN Continue;
			POPA;
			XORI CR;
			IF_A_EQ_THEN PrintLF;
			JR PrintLoop;
PrintLF:	LDYI @StrEnd;
			JSR Print;
			JR PrintLoop1; 
			
Continue:	POPA;
			LDXI @StrReady;
			JSR PrintChr;

			JSR GetCursorXY;	// set proper cursor X, Y...
			JSR SetOldCrsXY;
			
			LDAI 0x89AB;
			JSR PrintHex;
			
			INTON;	// and then enable interrupts
			
// -------------------------------------
// MainLoop START
// -------------------------------------
MainLoop:	LDYI TXTBUFFER;
			
			// clear text buffer
			CLRAX;
TxtClear:	STA, M[Y+X];
			CPXI TXTBUFLEN;
			IF_X_GE_THEN TxtCleared;
			INX, JR TxtClear;

TxtCleared: CLRX; // X holds position of cursor within the buffer
			// edit within the text buffer
			JSR CmdEdit;
			IF_A_GE_THEN ErrOrBrk;
			
			// print text buffer
			JSR Print;

			// execute command in text buffer
			JSR CmdExec;
			IF_A_GE_THEN ErrOrBrk;

			// dead loop
			JR MainLoop;
// -------------------------------------
// MainLoop END
// -------------------------------------

CmdExec:	JSR UART_IsBrk;
			IF_A_GE_THEN CmdBreak;
			LDAI 0xFFFF;
CmdBreak:	RRC, RTS;	// just return now with an error code
			
ErrOrBrk:	LDYI @StrBreak;
			LDXI ETX;	
			CPX, A;		// A = CTRL/C?
			IF_A_EQ_THEN Print;		// yes, just print break message
			PUSHA;		// save error code
			LDYI @StrError;
			JSR Print;
			POPA;		 // restore error code
			JSR PrintHexA;
			LDYI @StrEnd;
			JR Print;

CmdEdit:	JSR UART_GetChr;
			PUSHA;

			JSR PrintChr;

			LDA, M[S];
			XORI CR;	// Enter? 
			IF_A_EQ_THEN LeaveEdit;
			
			LDA, M[S];
			XORI ETX;	// CTRL-C? 
			IF_A_EQ_THEN BrkEdit;
			
			LDA, M[S];
			XORI CLS;	// CLS? 
			IF_A_EQ_THEN BrkEdit;

			LDA, M[S];
			XORI HOME;	// HOME? 
			IF_A_EQ_THEN BrkEdit;
			
			LDA, M[S];
			XORI BS;
			IF_A_EQ_THEN BSEdit;
			
			// "regular character"
			POPA;
			STA, M[Y+X];
			CPXI TXTBUFLEN;
			IF_X_EQ_THEN BumpEnd;
			CLRA;
			STA, M[Y+X];
			INX, JR CmdEdit;

			// break edit mode with AC set
BrkEdit:	POPA;
			LDAI 1;
			RRC;
			LDAI ETX;	// ETX code denoted break, not error
			RTS;
			
			// break edit mode with AC cleared
LeaveEdit:	POPA;
			CLRA;
			STA, M[Y+X];
			RRC, RTS;
			
			// clear current character and move one left
BSEdit:		POPA;
			CLRA;
			STA, M[Y+X];
			CPX, A;		// test if X == 0
			IF_X_EQ_THEN BumpStart;
			DEX, JR CmdEdit;

BumpStart:	PUSHX;
			PUSHY;
			LDYI @StrBeep;
Bumped:		JSR Print;
			POPY;
			POPX;
			JR CmdEdit;
			
BumpEnd:	PUSHX;
			PUSHY;
			LDYI @StrBack;
			JR Bumped;
			
#include "utils.sif";
#include "uart.sif";
#include "vga.sif";		
#include "strings.sif";
	
			
