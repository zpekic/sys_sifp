//---------------------------------------------------------------------------------------------
//	Hello world test code for SIFP (c) 2023-... zpekic@hotmail.com
//  Compile with https://github.com/zpekic/MicroCodeCompiler
//---------------------------------------------------------------------------------------------
// Test code to load into internal ROM of SIFP microcomputer
// Full description: 
// https://hackaday.io/project/173996-sifp-single-instruction-format-processor
//---------------------------------------------------------------------------------------------
			.code 10, 16, helloworld_code.mif, helloworld_code.cgf, helloworld_code.coe, cpu:helloworld_code.vhd, helloworld_code.hex, helloworld_code.bin, 2;
			.symbol 10, 256, helloworld_sym.mif, helloworld_sym.cgf, helloworld_sym.coe, sym:helloworld_sym.vhd, helloworld_sym.hex, helloworld_sym.bin, 32;

#include "sifp.mcc";
#include "sifp_sys.mcc";

//	---------------------------------------------------------------------------
			.org 0;
//	Execution starts at location 0
//	---------------------------------------------------------------------------
			NOP;
			JUMP;
			.to @Init;
			
//	---------------------------------------------------------------------------
//	interrupt handling routine
//	---------------------------------------------------------------------------
			.org 8;
			//TRACEON;
			PUSHA;
			PUSHX;
			PUSHY;

			MARK2;
			BRANCH;
			.into @GetOldCrsXY - $;
			PUSHY;
			PUSHX;
			MARK2;
			BRANCH;
			.into @GetRowBase - $;
			LDA, M[Y+X];	// get character from VGA RAM
			ANDI;
			.data 0xFF7F;	// revert to original
			STA, M[Y+X];
			MARK2;
			BRANCH;
			.into @GetCursorXY - $;
			CPX, M[POP];	// new X - old X
			CPY, M[POP];	// new Y - old Y
			IF_XZ;
			.branchto @CheckY - $;
			BRANCH;
			.to @NoFlip - $; 
CheckY:		IF_YZ;
			.branchto @Flip - $;
NoFlip:		MARK2;
			BRANCH;
			.into @SetOldCrsXY - $;
			BRANCH;
			.to @IntExit - $;
			
Flip:		MARK2;
			BRANCH;
			.into @GetCursorXY - $;
			MARK2;
			BRANCH;
			.into @GetRowBase - $;
			LDA, M[Y+X];	// get character from VGA RAM
			XORI;
			.data 0x0080;	// reverse back and forth
			STA, M[Y+X];
			
IntExit:	POPY;
			POPX;
			POPA;
			POPF;	// F and P were saved when entering the interrupt routine
			RTS;
//	---------------------------------------------------------------------------			

Init:		MARK2;
			BRANCH;
			.into @VGA_Init - $;
			LDXI;
			.data @StrReady;
			MARK2;
			BRANCH;
			.into @VGA_OutStr - $;

			TRACEON; 

			MARK2;
			BRANCH;
			.into @UART_Init - $;
			LDXI;
			.data @StrReady;
			MARK2;
			BRANCH;
			.into @UART_OutStr - $;

			INTON;	// enable interrupts
			
// -------------------------------------
// MainLoop START
// -------------------------------------
MainLoop:	LDYI;
			.data TXTBUFFER;
			
			// clear text buffer
			LDX, LDA, M[IMM];
			.data 0;
TxtClear:	STA, M[Y+X];
			CPXI;
			.data TXTBUFLEN;
			IF_XC;
			.branchto @TxtCleared - $;
			INX, BRANCH;
			.to @TxtClear - $;

TxtCleared: TRACEON;

			// edit within the text buffer
			MARK2;
			BRANCH;
			.into @CmdEdit - $;
			IF_AC;
			.branchto @ErrOrBrk - $;

			// print text buffer
			MARK2;
			BRANCH;
			.into @Print - $;
			
			// execute command in text buffer
			MARK2;
			BRANCH;
			.into @CmdExec - $;
			IF_AC;
			.branchto @ErrOrBrk - $;

			// dead loop
			BRANCH;
			.to @MainLoop - $;
// -------------------------------------
// MainLoop END
// -------------------------------------

CmdExec:	MARK2;
			BRANCH;
			.into @UART_IsBrk - $;
			IF_AC;
			.branchto @CmdBreak - $;
			LDAI;
			.data 0xFFFF;
			SRC;	
CmdBreak:	RTS;	// just return now with an error code
			
ErrOrBrk:	LDYI;
			.data @StrBreak;
			ANDI;
			.data 0xFFFF;	// check if 0
			IF_AZ;
			.branchto @Print - $;
			PUSHA;			// save error code
			LDYI;
			.data @StrError;
			MARK2;
			BRANCH;
			.into @Print - $;
			POPA;			// restore error code
			MARK2;
			BRANCH;
			.into @PrintHexA - $;
			LDYI;
			.data @StrEnd;
			BRANCH;
			.to @Print - $;

CmdEdit:	MARK2;
			BRANCH;
			.into @UART_GetChr - $;
			PUSHA;

			MARK2;
			BRANCH;
			.into @PrintChr - $;

			LDA, M[S];
			XORI;
			.data CR;	// Enter? 
			IF_AZ;
			.branchto @LeaveEdit - $;
			
			LDA, M[S];
			XORI;
			.data ETX;	// CTRL-C? 
			IF_AZ;
			.branchto @BrkEdit - $;
			
			LDA, M[S];
			XORI;
			.data CLS;	// CLS? 
			IF_AZ;
			.branchto @BrkEdit - $;

			LDA, M[S];
			XORI;
			.data HOME;	// HOME? 
			IF_AZ;
			.branchto @BrkEdit - $;
			
			LDA, M[S];
			XORI;
			.data BS;
			IF_AZ;
			.branchto @BSEdit - $;
			
			// "regular character"
			POPA;
			STA, M[Y+X];
			CPXI;
			.data TXTBUFLEN;
			IF_XZ;
			.branchto @BumpEnd - $;
			LDAI;
			.data 0;
			STA, M[Y+X];
			INX, BRANCH;
			.to @CmdEdit - $;

			// break edit mode with AC set
BrkEdit:	POPA;
			LDAI;
			.data 1;
			SRC;
			RTS;
			
			// break edit mode with AC cleared
LeaveEdit:	POPA;
			LDAI;
			.data 0;
			STA, M[Y+X];
			SRC;
			RTS;
			
			// clear current character and move one left
BSEdit:		POPA;
			LDAI;
			.data 0;
			STA, M[Y+X];
			CPXI;
			.data 0;
			IF_XZ;
			.branchto @BumpStart - $;
			DEX, BRANCH;
			.to @CmdEdit - $;

BumpStart:	PUSHX;
			PUSHY;
			LDYI;
			.data @StrBeep;
Bumped:		MARK2;
			BRANCH;
			.into @Print - $;
			POPY;
			POPX;
			BRANCH;
			.to @CmdEdit - $;
			
BumpEnd:	PUSHX;
			PUSHY;
			LDYI;
			.data @StrBack;
			BRANCH;
			.to @Bumped - $;
			
#include "utils.sif";
#include "uart.sif";
#include "vga.sif";		
#include "strings.sif";
	
			
