//---------------------------------------------------------------------------------------------
//	Hello world test code for SIFP (c) 2023-... zpekic@hotmail.com
//  Compile with https://github.com/zpekic/MicroCodeCompiler
//---------------------------------------------------------------------------------------------
// Test code to load into internal ROM of SIFP microcomputer
// Full description: 
// https://hackaday.io/project/173996-sifp-single-instruction-format-processor
//---------------------------------------------------------------------------------------------
			.code 10, 16, helloworld_code.mif, helloworld_code.cgf, helloworld_code.coe, cpu:helloworld_code.vhd, helloworld_code.hex, helloworld_code.bin, 2;
			.symbol 10, 256, helloworld_sym.mif, helloworld_sym.cgf, helloworld_sym.coe, sym:helloworld_sym.vhd, helloworld_sym.hex, helloworld_sym.bin, 32;

#include "sifp.mcc";
#include "sifp_sys.mcc";

//	---------------------------------------------------------------------------
			.org 0;
//	Execution starts at location 0
//	---------------------------------------------------------------------------
			NOP;
			JUMP;
			.to @Init;
			
//	---------------------------------------------------------------------------
//	interrupt handling routine
//	---------------------------------------------------------------------------
			.org 8;
			//TRACEON;
			PUSHA;
			PUSHX;
			PUSHY;

			MARK2;
			BRANCH;
			.into @GetCursorXY - $;
			PUSHY;
			PUSHX;
			MARK2;
			BRANCH;
			.into @GetOldCrsXY - $;
			CPX, M[POP];	// old X - new X
			CPY, M[POP];	// old Y - new Y
			IF_XZ;
			.branchto @CheckY - $;
			BRANCH;
			.to @Revert - $; 
CheckY:		IF_YZ;
			.branchto @Flip - $;
			BRANCH;
			.to @Revert - $;

Flip:		MARK2;
			BRANCH;
			.into @GetRowBase - $;
			LDA, M[Y+X];	// get character from VGA RAM
			XORI;
			.data 0x0080;	// reverse back and forth
			STA, M[Y+X];
			BRANCH;
			.to @IntExit - $;
			
Revert:		MARK2;
			BRANCH;
			.into @GetRowBase - $;
			LDA, M[Y+X];	// get character from VGA RAM
			ANDI;
			.data 0xFF7F;	// revert to original
			STA, M[Y+X];
			MARK2;
			BRANCH;
			.into @GetCursorXY - $;
			MARK2;
			BRANCH;
			.into @SetOldCrsXY - $;

IntExit:	POPY;
			POPX;
			POPA;
			POPF;	// F and P were saved when entering the interrupt routine
			RTS;
//	---------------------------------------------------------------------------			

Init:		MARK2;
			BRANCH;
			.into @VGA_Init - $;
			LDXI;
			.data @StrHWorld;
			MARK2;
			BRANCH;
			.into @VGA_OutStr - $;

			MARK2;
			BRANCH;
			.into @UART_Init - $;
			LDXI;
			.data @StrHWorld;
			MARK2;
			BRANCH;
			.into @UART_OutStr - $;

			//TRACEON; 
			INTON;	// enable interrupts
			
EchoLoop:	MARK2;
			BRANCH;
			.into @UART_GetChr - $;
EchoOut:	PUSHA;
			MARK2;
			BRANCH;
			.into @UART_OutChr - $;
			MARK2;
			BRANCH;
			.into @VGA_OutChr - $;
			POPA;
			XORI;
			.data CR;
			IF_AZ;
			.branchto @EchoLF - $;
 			JUMP;
			.to @EchoLoop;
EchoLF:		LDAI;
			.data LF;
			JUMP;
			.to @EchoOut;
			
StrClear:	.data CLS;
			.data 0;
			
StrHWorld:	.data 'H';
			.data 'e';
			.data 'l';
			.data 'l';
			.data 'o';
			.data ' ';
			.data 'W';
			.data 'o';
			.data 'r';
			.data 'l';
			.data 'd';
			.data '!';
StrEnd:		.data CR;
			.data LF;
			.data 0;
				
#include "utils.sif";
#include "uart.sif";
#include "vga.sif";			
			
