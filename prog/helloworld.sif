//---------------------------------------------------------------------------------------------
//	Hello world test code for SIFP (c) 2023-... zpekic@hotmail.com
//  Compile with https://github.com/zpekic/MicroCodeCompiler
//---------------------------------------------------------------------------------------------
// Test code to load into internal ROM of SIFP microcomputer
// Full description: 
// https://hackaday.io/project/173996-sifp-single-instruction-format-processor
//---------------------------------------------------------------------------------------------
			.code 9, 16, helloworld_code.mif, helloworld_code.cgf, helloworld_code.coe, cpu:helloworld_code.vhd, helloworld_code.hex, helloworld_code.bin, 2;
			.symbol 9, 256, helloworld_sym.mif, helloworld_sym.cgf, helloworld_sym.coe, sym:helloworld_sym.vhd, helloworld_sym.hex, helloworld_sym.bin, 32;

#include "sifp.mcc";
#include "sifp_sys.mcc";

//	---------------------------------------------------------------------------
			.org 0;
//	Execution starts at location 0
//	---------------------------------------------------------------------------
			NOP;
			
			MARK2;
			BRANCH;
			.into @UART_Init - $;
			
			LDXI;
			.data @StrHWorld;
			MARK2;
			BRANCH;
			.into @UART_OutStr - $;
			
EchoLoop:	MARK2;
			BRANCH;
			.into @UART_GetChr - $;
			MARK2;
			BRANCH;
			.into @UART_OutChr - $;
			MARK2;
			BRANCH;
			.into @VGA_OutChr - $;
 			BRANCH;
			.to @EchoLoop - $;
			
UART_GetChr:PUSHY;
			LDYI;
			.data UART_STATUS;
RdStatus0:	LDA, M[Y];
			SRC;		// bit 0 is RDRF (receiver data register full)
			IF_AC;
			.branchto @GetChr - $;
			BRANCH;
			.to @RdStatus0 - $;
GetChr:		INY;		// point to UART data register
			LDA, M[Y];
			ANDI;
			.data 0x00FF;	// UART is connected to LSB
			POPY;
			RTS;

UART_OutChr:PUSHY;
			PUSHA;
			LDYI;
			.data UART_STATUS;
RdStatus1:	LDA, M[Y];
			SRC;
			SRC;		// bit 1 is TDRE (transmit register empty)
			IF_AC;
			.branchto @OutChr - $;
			BRANCH;
			.to @RdStatus1 - $;
OutChr:		INY, LDA, M[POP];	// Y points to UART data register, get the char back		
			STA, M[Y];
			POPY;
			RTS;
			
UART_OutStr:LDA, M[X];
			IF_AZ;
			.branchto @Done - $;
			MARK2;
			BRANCH;
			.into @UART_OutChr - $;
			INX, BRANCH;
			.data @UART_OutStr - $;
Done:		RTS;

StrClear:	.data CLS;
			.data 0;
			
StrHWorld:	.data 'H';
			.data 'e';
			.data 'l';
			.data 'l';
			.data 'o';
			.data ' ';
			.data 'W';
			.data 'o';
			.data 'r';
			.data 'l';
			.data 'd';
			.data '!';
			.data CR;
			.data LF;
			.data 0;
			
		
UART_Init: 	LDYI;
			.data UART_CONTROL;
			LDAI;
			.data 3;	// reset
			STA, M[Y];
			LDAI;
			.data 0x10;	// all int off, 8N2, baudrate / 1
			STA, M[Y];
			RTS;
			
#include "utils.sif";			
#include "vga.sif";			
			
