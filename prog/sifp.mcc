//---------------------------------------------------------------------------------------------
//	Include to adapt mcc as assembler for SIFP (c) 2023-... zpekic@hotmail.com
//  More about mcc:  https://github.com/zpekic/MicroCodeCompiler
//---------------------------------------------------------------------------------------------
// Full description: 
// https://hackaday.io/project/173996-sifp-single-instruction-format-processor
//---------------------------------------------------------------------------------------------
// define slices of the instruction word format
//
// 16-bit program counter (has no flags, always increment during fetch phase, changes as below during execute phase)
r_p			.valfield 4 values
				NOP,				// continue (increment P during next fetch phase)
				M[IMM],				// output value as address, increment (used for immediate values)
				BRANCH|IF_TRUE,		// unconditional branch (add word pointed by P)
				JUMP|GOTO,			// unconditional jump (load with word pointed by P)
				LDP,				// load from incoming data (mostly from stack, for return)
				STP4,				// put P + 4 to internal data bus
				STP2,				// put P + 2 to internal data bus
				STP,				// put P to internal data bus (mostly to output during trace mode)
				BAC|IF_AC|IF_A_GE,	// if A flag C set add word pointed by P (branch), else increment P
				BAZ|IF_AZ|IF_A_EQ,	// if A flag Z set add word pointed by P (branch), else increment P
				BXC|IF_XC|IF_X_GE,
				BXZ|IF_XZ|IF_X_EQ,
				BYC|IF_YC|IF_Y_GE,
				BYZ|IF_YZ|IF_Y_EQ,
				BSC|IF_SC|IF_S_GE,
				BSZ|IF_SZ|IF_S_EQ
				default NOP;
//				
// 16-bit accumulator (has own carry (AC) and zero (AZ) flags, changes only during execute phases)
r_a			.valfield 3 values
				NOA,	// no operation on A register
				SBC,	// substract incoming data (AC, AZ)
				XOR,	// logical xor with incoming data (AZ)
				RRC,	// rotate right through carry (AC, AZ)
				LDA,	// load with incoming data (AZ)
				ADC,	// add incoming data and carry flag (AC, AZ)
				AND,	// logical and with incoming data (AZ)
				STA|A	// output value as data
				default NOA;
//
// 16-bit index register X (has own carry (XC) and zero (XZ) flags, changes only during execute phases)
r_x			.valfield 3 values
				NOX,	// no operation on X register 
				CPX,	// compare with incoming data (XC, XZ)
				INX,	// increment by 1	(XC, XZ)
				DEX,	// decrement by 1	(XC, XZ)
				LDX,	// load with incoming data (XZ)
				ADX,	// add incoming data (XC, XZ)
				M[X],	// output value as address 
				STX|X	// output value as data
				default NOX;
//				
// 16-bit index register Y (has own carry (YC) and zero (YZ) flags, changes only during execute phases)			
r_y			.valfield 3 values
				NOY,	// no operation on Y register 
				CPY,	// compare with incoming data (YC, YZ)
				INY,	// increment by 1	(YC, YZ)
				DEY,	// decrement by 1	(YC, YZ)
				LDY,	// load with incoming data (YZ)
				ADY,	// add incoming data (YC, YZ)
				M[Y],	// output value as address 
				STY|Y	// output value as data
				default NOY;
//
// 16-bit stack pointer S (has own carry (SC) and zero (SZ) flags, changes only during execute phases)
r_s			.valfield 3 values
				NOS,	// no operation on S register 
				CPS,	// compare with incoming data (SC, SZ)
				M[POP],	// address is S, then increment
				M[PUSH],// address is S - 1, then decrement
				LDS,	// load with incoming data (SZ)
				ADS,	// add incoming data (SC, SZ)
				M[S],	// output value as address (use to access stack top in memory) 
				STS|S	// output value as data
				default NOS;

// other registers

// F ... 16bit flags register (MSByte = IE, TE; LSByte = Flags for A, X, Y, S)
//			during execute phase, F is updated either from:
//			A, X, Y, S flags -OR-
//			memory data bus if stack pointer "pops" and all other registers as inactive (NOP)
//			it can be saved during execute phase if stack pointer "pushes" and all other registers are inactive (NOP)
// Flag bits arrangement:
//	15 | 14 | 13 | 12 | 11 | 10 |  9 |  8 |  7 |  6 |  5 |  4 |  3 |  2 |  1 |  0 |
//	IE | TE | ?? | ?? | ?? | ?? | ?? | ?? | AC | XC | YC | SC | AZ | XZ | YZ | SZ |
//	IE ... set to 1 to enable interrupts (cleared on reset)
//  TE ... set to 1 to enable "tracing" (output register values after each instruction, cleared on reset)

// I ... 16bit instruction register, loaded from memory data bus during fetch phase only

// 16-bit data can be directly in instruction stream (immediate value, relative or absolute address)
data16		.valfield r_p .. r_s values * default 0;
						
// "aliases" are evaluated as simple text replacement of label with everything between .alias and ; 
.data		.alias  data16 = ;
.absolute	.alias  data16 = @;
.relative	.alias  data16 = !$ + 1 + @;	// same as @foo - $
// Base + offset addressing mode
M[Y+X]		.alias  r_x = M[X], r_y = M[Y];
M[X+Y]		.alias  r_x = M[X], r_y = M[Y];
M[S+X]		.alias  r_x = M[X], r_s = M[S];
M[S+Y]		.alias  r_y = M[Y], r_s = M[S];
// Convenient stack operations
RTS			.alias 	r_p = LDP, r_s = M[POP];
//MARK2		.alias 	r_p = STP2, r_s = M[PUSH];
PUSHA		.alias  r_a = STA, r_s = M[PUSH];
POPA		.alias  r_a = LDA, r_s = M[POP];
PUSHX		.alias  r_x = STX, r_s = M[PUSH];
POPX		.alias  r_x = LDX, r_s = M[POP];
PUSHY		.alias  r_y = STY, r_s = M[PUSH];
POPY		.alias  r_y = LDY, r_s = M[POP];
// Convenient immediate operations
LDAI		.alias  r_p = M[IMM], r_a = LDA \ data16 =;
XORI		.alias  r_p = M[IMM], r_a = XOR \ data16 =;
SBCI		.alias  r_p = M[IMM], r_a = SBC \ data16 =;
ADCI		.alias  r_p = M[IMM], r_a = ADC \ data16 =;
ANDI		.alias  r_p = M[IMM], r_a = AND \ data16 =;
LDXI		.alias  r_p = M[IMM], r_x = LDX \ data16 =;
//ADXI		.alias  r_p = M[IMM], r_x = ADX \ data16 =;
CPXI		.alias  r_p = M[IMM], r_x = CPX \ data16 =;
LDYI		.alias  r_p = M[IMM], r_y = LDY \ data16 =;
ADYI		.alias  r_p = M[IMM], r_y = ADY \ data16 =;
CPYI		.alias  r_p = M[IMM], r_y = CPY \ data16 =;
//LDSI		.alias  r_p = M[IMM], r_s = LDS \ data16 =;
//ADSI		.alias  r_p = M[IMM], r_s = ADS \ data16 =;
//CPSI		.alias  r_p = M[IMM], r_s = CPS \ data16 =;
// Convenient clear and check for zero operations (internal data bus is 0 by default if not driven)
CLRA		.alias  r_p = NOP, r_a = LDA, r_x = NOX, r_y = NOY, r_s = NOS;	
CLRX		.alias  r_p = NOP, r_a = NOA, r_x = LDX, r_y = NOY, r_s = NOS;	
CLRY		.alias  r_p = NOP, r_a = NOA, r_x = NOX, r_y = LDY, r_s = NOS;	
//CLRAX		.alias  r_p = NOP, r_a = LDA, r_x = LDX, r_y = NOY, r_s = NOS;	
//CLRAY		.alias  r_p = NOP, r_a = LDA, r_x = NOX, r_y = LDY, r_s = NOS;	
CLRXY		.alias  r_p = NOP, r_a = NOA, r_x = LDX, r_y = LDY, r_s = NOS;	
//CLRAXY	.alias  r_p = NOP, r_a = LDA, r_x = LDX, r_y = LDY, r_s = NOS;	
//CHKA		.alias  r_p = NOP, r_a = XOR, r_x = NOX, r_y = NOY, r_s = NOS;	
CHKX		.alias  r_p = NOP, r_a = NOA, r_x = CPX, r_y = NOY, r_s = NOS;	
CHKY		.alias  r_p = NOP, r_a = NOA, r_x = NOX, r_y = CPY, r_s = NOS;	
// Rotate left through carry replacement
RLC			.alias STA, M[PUSH] \ ADC, M[POP];
// Transfer registers
TAY			.alias LDY, A;
TYA			.alias LDA, Y;
// Load A from stack top, and xor with immediate value (for match)
CASE		.alias r_a = LDA, r_s = M[S] \ r_p = M[IMM], r_a = XOR \ data16 =;

//
// Special case instruction combinations
FTOS		.alias  r_p = NOP, r_a = NOA, r_x = NOX, r_y = NOY, r_s = M[S];		// mostly for flag output in trace mode 
PUSHF		.alias  r_p = NOP, r_a = NOA, r_x = NOX, r_y = NOY, r_s = M[PUSH];	// flags to stack
POPF		.alias  r_p = NOP, r_a = NOA, r_x = NOX, r_y = NOY, r_s = M[POP];	// pick up flags from stack
HALT		.alias  r_p = M[IMM], r_a = A, r_x = X, r_y = Y, r_s = S;			// ABUS will indicate where CPU halted
INTON		.alias  r_p = NOP, r_a = A, r_x = X, r_y = Y, r_s = S;			// Enable interrupts (set flag_ie to 1)
INTOFF		.alias  r_p = STP4, r_a = A, r_x = X, r_y = Y, r_s = S;			// Disable interrupts (set flag_ie to 0)
TRACEON		.alias  r_p = STP2, r_a = A, r_x = X, r_y = Y, r_s = S;			// Enable tracing (set flag_te to 1)
TRACEOFF	.alias  r_p = STP, r_a = A, r_x = X, r_y = Y, r_s = S;			// Disable tracing (set flag_te to 0)

//
// Multi line (can reuse all aliases defined above)
JA			.alias JUMP \ .absolute;
JR			.alias BRANCH \ .relative;
JSA			.alias r_p = STP2, r_s = M[PUSH] \ JUMP \ .absolute;
JSR			.alias r_p = STP2, r_s = M[PUSH] \ BRANCH \ .relative;
RTF			.alias POPF \ RTS;

// Convenient conditional jumps
IF_AC_THEN		.alias	IF_A_GE \ .relative;						// AC set
IF_A_GE_THEN	.alias	IF_A_GE \ .relative;						// AC set
IF_A_LT_THEN	.alias	IF_A_GE \ data16 = 3 \ BRANCH \ .relative;	// AC not set
IF_A_EQ_THEN	.alias	IF_A_EQ \ .relative;						// AZ set
IF_A_NE_THEN	.alias	IF_A_EQ \ data16 = 3 \ BRANCH \ .relative;	// AZ not set
IF_X_GE_THEN	.alias	IF_X_GE \ .relative;						// XC set
IF_X_LT_THEN	.alias	IF_X_GE \ data16 = 3 \ BRANCH \ .relative;	// XC not set
IF_X_EQ_THEN	.alias	IF_X_EQ \ .relative;						// XZ set
IF_X_NE_THEN	.alias	IF_X_EQ \ data16 = 3 \ BRANCH \ .relative;	// XZ not set
IF_Y_GE_THEN	.alias	IF_Y_GE \ .relative;						// YC set
IF_Y_LT_THEN	.alias	IF_Y_GE \ data16 = 3 \ BRANCH \ .relative;	// YC not set
IF_Y_EQ_THEN	.alias	IF_Y_EQ \ .relative;						// YZ set
IF_Y_NE_THEN	.alias	IF_Y_EQ \ data16 = 3 \ BRANCH \ .relative;	// YZ not set
