//---------------------------------------------------------------------------------------------
//	Include to adapt mcc as assembler SIFP (c) 2023-... zpekic@hotmail.com
//  More about mcc:  https://github.com/zpekic/MicroCodeCompiler
//---------------------------------------------------------------------------------------------
// Full description: 
// https://hackaday.io/project/173996-sifp-single-instruction-format-processor
//---------------------------------------------------------------------------------------------
// define slices of the instruction word format
//
// 16-bit program counter (has no flags, changes during both fetch and execute phases)
r_p			.valfield 4 values
				NOP,				// continue (increment P during fetch phase)
				LDP|JMP|JUMP|GOTO,	// load from incoming data (jump)
				ADP|BRANCH, 		// add incoming data (relative jump / branch)
				P2,					// output P+x as data (usually for push)
				P3,
				P4,
				P0,
				M[IMM],		// output value as address, increment (used for immediate values)
				BAC|IF_AC|IF_A_GE,	// branch if A flag C set
				BAZ|IF_AZ|IF_A_EQ,	// branch if A flag Z set
				BXC|IF_XC|IF_X_GE,
				BXZ|IF_XZ|IF_X_EQ,
				BYC|IF_YC|IF_Y_GE,
				BYZ|IF_YZ|IF_Y_EQ,
				BSC|IF_SC|IF_S_GE,
				BSZ|IF_SZ|IF_S_EQ	// branch is S flag Z set
				default NOP;
//				
// 16-bit accumulator (has own carry (AC) and zero (AZ) flags, changes only during execute phases)
r_a			.valfield 3 values
				NOA,	// no operation on A register 
				LDA,	// load with incoming data (AZ)
				XOR,	// logical xor with incoming data (AZ)
				SLC,	// shift left through carry	(AC, AZ)
				SRC,	// shift right through carry (AC, AZ)
				ADC,	// add incoming data and carry flag (AC, AZ)
				AND,	// logical and with incoming data (AZ)
				STA|A	// output value as data
				default NOA;
//
// 16-bit index register X (has own carry (XC) and zero (XZ) flags, changes only during execute phases)
r_x			.valfield 3 values
				NOX,	// no operation on X register 
				CPX,	// compare with incoming data (XC, XZ)
				INX,	// increment by 1	(XC, XZ)
				DEX,	// decrement by 1	(XC, XZ)
				LDX,	// load with incoming data (XZ)
				ADX,	// add incoming data (XC, XZ)
				M[X],	// output value as address 
				STX|X	// output value as data
				default NOX;
//				
// 16-bit index register Y (has own carry (YC) and zero (YZ) flags, changes only during execute phases)			
r_y			.valfield 3 values
				NOY,	// no operation on Y register 
				CPY,	// compare with incoming data (YC, YZ)
				INY,	// increment by 1	(YC, YZ)
				DEY,	// decrement by 1	(YC, YZ)
				LDY,	// load with incoming data (YZ)
				ADY,	// add incoming data (YC, YZ)
				M[Y],	// output value as address 
				STY|Y	// output value as data
				default NOY;
// 16-bit stack pointer S  (has own carry (SC) and zero (SZ) flags, changes only during execute phases)
r_s			.valfield 3 values
				NOS,	// no operation on X register 
				CPS,	// compare with incoming data (SC, SZ)
				M[POP],	// address is S, then increment
				M[PUSH],// address is S - 1, then decrement
				LDS,	// load with incoming data (SZ)
				ADS,	// add incoming data (SC, SZ)
				M[S],	// output value as address (use to access stack top in memory) 
				STS|S	// output value as data
				default NOS;

// other registers
// F ... 16bit flags register (MSByte = not used, LSByte = Flags for A, X, Y, S)
//			during execute phase, F is updated either from:
//			A, X, Y, S flags -OR-
//			memory data bus if stack pointer "pops" and all other registers as inactive (NOP)
//			it can be saved during execute phase if stack pointer "pushes" and all other registers are inactive (NOP)
// I ... 16bit instruction register, loaded from memory data bus during fetch phase only

// 16-bit data can be directly in instruction stream (immediate value, relative or absolute address)
data16		.valfield r_p .. r_s values * default 0;
						
// "aliases" are evaluated as simple text replacement of label with everything between .alias and ; 
.data		.alias  data16 = ;
.to			.alias  data16 = ;
.branchto	.alias  data16 = ;
.into		.alias 	data16 = ;
// Base + offset addressing mode
M[Y+X]		.alias  r_x = M[X], r_y = M[Y];
M[X+Y]		.alias  r_x = M[X], r_y = M[Y];
// Convenient stack operations
RTS			.alias 	r_p = JMP, r_s = M[POP];
MARK2		.alias 	r_p = P2, r_s = M[PUSH];
PUSHA		.alias  r_a = STA, r_s = M[PUSH];
POPA		.alias  r_a = LDA, r_s = M[POP];
PUSHX		.alias  r_x = STX, r_s = M[PUSH];
POPX		.alias  r_x = LDX, r_s = M[POP];
PUSHY		.alias  r_y = STY, r_s = M[PUSH];
POPY		.alias  r_y = LDY, r_s = M[POP];
// Convenient immediate operations
LDAI		.alias  r_p = M[IMM], r_a = LDA;
XORI		.alias  r_p = M[IMM], r_a = XOR;
ADCI		.alias  r_p = M[IMM], r_a = ADC;
ANDI		.alias  r_p = M[IMM], r_a = AND;
LDXI		.alias  r_p = M[IMM], r_x = LDX;
ADXI		.alias  r_p = M[IMM], r_x = ADX;
CPXI		.alias  r_p = M[IMM], r_x = CPX;
LDYI		.alias  r_p = M[IMM], r_y = LDY;
ADYI		.alias  r_p = M[IMM], r_y = ADY;
CPYI		.alias  r_p = M[IMM], r_y = CPY;
LDSI		.alias  r_p = M[IMM], r_s = LDS;
ADSI		.alias  r_p = M[IMM], r_s = ADS;
CPSI		.alias  r_p = M[IMM], r_s = CPS;

//
// Special case instruction combinations
FTOS		.alias  r_p = NOP, r_a = NOA, r_x = NOX, r_y = NOY, r_s = M[S];		// mostly for flag output is trace mode 
PUSHF		.alias  r_p = NOP, r_a = NOA, r_x = NOX, r_y = NOY, r_s = M[PUSH];	// flags to stack
POPF		.alias  r_p = NOP, r_a = NOA, r_x = NOX, r_y = NOY, r_s = M[POP];	// pick up flags from stack
HALT		.alias  r_p = M[IMM], r_a = A, r_x = X, r_y = Y, r_s = S;			// ABUS will indicate where CPU halted

