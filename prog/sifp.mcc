//---------------------------------------------------------------------------------------------
//	Include to adapt mcc as assembler for SIFP (c) 2023-... zpekic@hotmail.com
//  More about mcc:  https://github.com/zpekic/MicroCodeCompiler
//---------------------------------------------------------------------------------------------
// Full description: 
// https://hackaday.io/project/173996-sifp-single-instruction-format-processor
//---------------------------------------------------------------------------------------------
// define slices of the instruction word format
//
// 16-bit program counter (has no flags, always increment during fetch phase, changes as below during execute phase)
r_p			.valfield 4 values
				NOP,				// continue (increment P during next fetch phase)
				M[IMM],				// output value as address, increment (used for immediate values)
				BRANCH|IF_TRUE,		// unconditional branch (add word pointed by P)
				JUMP|GOTO,			// unconditional jump (load with word pointed by P)
				LDP,				// load from incoming data (mostly from stack, for return)
				STP4,				// put P + 4 to internal data bus
				STP2,				// put P + 2 to internal data bus
				STP,				// put P to internal data bus (mostly to output during trace mode)
				BAC|IF_AC|IF_A_GE,	// if A flag C set add word pointed by P (branch), else increment P
				BAZ|IF_AZ|IF_A_EQ,	// if A flag Z set add word pointed by P (branch), else increment P
				BXC|IF_XC|IF_X_GE,
				BXZ|IF_XZ|IF_X_EQ,
				BYC|IF_YC|IF_Y_GE,
				BYZ|IF_YZ|IF_Y_EQ,
				BSC|IF_SC|IF_S_GE,
				BSZ|IF_SZ|IF_S_EQ
				default NOP;
//				
// 16-bit accumulator (has own carry (AC) and zero (AZ) flags, changes only during execute phases)
r_a			.valfield 3 values
				NOA,	// no operation on A register
				SBC,	// substract incoming data (AC, AZ)
				XOR,	// logical xor with incoming data (AZ)
				RRC,	// rotate right through carry (AC, AZ)
				LDA,	// load with incoming data (AZ)
				ADC,	// add incoming data and carry flag (AC, AZ)
				AND,	// logical and with incoming data (AZ)
				STA|A	// output value as data
				default NOA;
//
// 16-bit index register X (has own carry (XC) and zero (XZ) flags, changes only during execute phases)
r_x			.valfield 3 values
				NOX,	// no operation on X register 
				CPX,	// compare with incoming data (XC, XZ)
				INX,	// increment by 1	(XC, XZ)
				DEX,	// decrement by 1	(XC, XZ)
				LDX,	// load with incoming data (XZ)
				ADX,	// add incoming data (XC, XZ)
				M[X],	// output value as address 
				STX|X	// output value as data
				default NOX;
//				
// 16-bit index register Y (has own carry (YC) and zero (YZ) flags, changes only during execute phases)			
r_y			.valfield 3 values
				NOY,	// no operation on Y register 
				CPY,	// compare with incoming data (YC, YZ)
				INY,	// increment by 1	(YC, YZ)
				DEY,	// decrement by 1	(YC, YZ)
				LDY,	// load with incoming data (YZ)
				ADY,	// add incoming data (YC, YZ)
				M[Y],	// output value as address 
				STY|Y	// output value as data
				default NOY;
//
// 16-bit stack pointer S (has own carry (SC) and zero (SZ) flags, changes only during execute phases)
r_s			.valfield 3 values
				NOS,	// no operation on S register 
				CPS,	// compare with incoming data (SC, SZ)
				M[POP],	// address is S, then increment
				M[PUSH],// address is S - 1, then decrement
				LDS,	// load with incoming data (SZ)
				ADS,	// add incoming data (SC, SZ)
				M[S],	// output value as address (use to access stack top in memory) 
				STS|S	// output value as data
				default NOS;

// other registers
// F ... 16bit flags register (MSByte = not used, LSByte = Flags for A, X, Y, S)
//			during execute phase, F is updated either from:
//			A, X, Y, S flags -OR-
//			memory data bus if stack pointer "pops" and all other registers as inactive (NOP)
//			it can be saved during execute phase if stack pointer "pushes" and all other registers are inactive (NOP)
// I ... 16bit instruction register, loaded from memory data bus during fetch phase only

// 16-bit data can be directly in instruction stream (immediate value, relative or absolute address)
data16		.valfield r_p .. r_s values * default 0;
						
// "aliases" are evaluated as simple text replacement of label with everything between .alias and ; 
.data		.alias  data16 = ;
.absolute	.alias  data16 = @;
.relative	.alias  data16 = !$ + 1 + @;	// same as @foo - $
// Base + offset addressing mode
M[Y+X]		.alias  r_x = M[X], r_y = M[Y];
M[X+Y]		.alias  r_x = M[X], r_y = M[Y];
// Convenient stack operations
RTS			.alias 	r_p = LDP, r_s = M[POP];
MARK2		.alias 	r_p = STP2, r_s = M[PUSH];
PUSHA		.alias  r_a = STA, r_s = M[PUSH];
POPA		.alias  r_a = LDA, r_s = M[POP];
PUSHX		.alias  r_x = STX, r_s = M[PUSH];
POPX		.alias  r_x = LDX, r_s = M[POP];
PUSHY		.alias  r_y = STY, r_s = M[PUSH];
POPY		.alias  r_y = LDY, r_s = M[POP];
// Convenient immediate operations
LDAI		.alias  r_p = M[IMM], r_a = LDA;
XORI		.alias  r_p = M[IMM], r_a = XOR;
ADCI		.alias  r_p = M[IMM], r_a = ADC;
ANDI		.alias  r_p = M[IMM], r_a = AND;
LDXI		.alias  r_p = M[IMM], r_x = LDX;
ADXI		.alias  r_p = M[IMM], r_x = ADX;
CPXI		.alias  r_p = M[IMM], r_x = CPX;
LDYI		.alias  r_p = M[IMM], r_y = LDY;
ADYI		.alias  r_p = M[IMM], r_y = ADY;
CPYI		.alias  r_p = M[IMM], r_y = CPY;
LDSI		.alias  r_p = M[IMM], r_s = LDS;
ADSI		.alias  r_p = M[IMM], r_s = ADS;
CPSI		.alias  r_p = M[IMM], r_s = CPS;

//
// Special case instruction combinations
FTOS		.alias  r_p = NOP, r_a = NOA, r_x = NOX, r_y = NOY, r_s = M[S];		// mostly for flag output in trace mode 
PUSHF		.alias  r_p = NOP, r_a = NOA, r_x = NOX, r_y = NOY, r_s = M[PUSH];	// flags to stack
POPF		.alias  r_p = NOP, r_a = NOA, r_x = NOX, r_y = NOY, r_s = M[POP];	// pick up flags from stack
HALT		.alias  r_p = M[IMM], r_a = A, r_x = X, r_y = Y, r_s = S;			// ABUS will indicate where CPU halted
INTON		.alias  r_p = NOP, r_a = A, r_x = X, r_y = Y, r_s = S;			// Enable interrupts (set flag_ie to 1)
INTOFF		.alias  r_p = STP4, r_a = A, r_x = X, r_y = Y, r_s = S;			// Disable interrupts (set flag_ie to 0)
TRACEON		.alias  r_p = STP2, r_a = A, r_x = X, r_y = Y, r_s = S;			// Enable tracing (set flag_te to 1)
TRACEOFF	.alias  r_p = STP, r_a = A, r_x = X, r_y = Y, r_s = S;			// Disable tracing (set flag_te to 0)

