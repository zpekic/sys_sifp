CURSOR_X	.alias RAM_BASE + 0;
CURSOR_Y	.alias RAM_BASE + 1;

// Display ASCII in A at row Y, column X	
			.org $;

VGA_OutChr: PUSHA;			// save ASCII
			XORI;
			.data CR;		// is it clear screen?
			IF_AZ;
			.branchto @VGA_CR - $;

			LDA, M[S];
			XORI;
			.data LF;		
			IF_AZ; 
			.branchto @VGA_LF - $;

			LDA, M[S];
			XORI;
			.data HOME;
			IF_AZ; 
			.branchto @VGA_HOME - $;
			
			LDA, M[S];
			XORI;
			.data CLS;
			IF_AZ; 
			.branchto @VGA_CLS - $;
			
//			default output
			MARK2;
			BRANCH;
			.into @GetCursorXY - $;	// get cursor row, col from RAM
			MARK2;
			BRANCH;
			.into @DisplayAt - $;
			INX;
			CPXI;
			.data VGA_COLS;
			IF_X_GE;
			.branchto @NextRow - $;
			BRANCH;
			.to @SetCursorXY - $;
			
NextRow:	LDXI;
			.data 0;
NextRow1:	INY;
			CPYI;
			.data VGA_ROWS;
			IF_Y_GE;
			.branchto @ScrollUp - $;
			BRANCH;
			.to @SetCursorXY - $;

ScrollUp:	NOP;
			LDYI;
			.data 0;
NxtRow:		PUSHY; 		// we will need row later
			LDXI;
			.data 0;
NxtCol:		PUSHX;		// we will need column later
			MARK2;
			BRANCH;
			.into @GetRowBase - $;
			PUSHY;		// destination base on stack
			ADYI;		// add to get source base
			.data VGA_ROWS;
			LDA, M[Y+X];	// get character from VGA RAM
			POPY;			// destination base
			STA, M[Y+X];	// store character to one row below, same column
			INX;			// next column
			CPXI;
			.data VGA_COLS;
			IF_X_GE;
			.branchto @ChkRow - $;
			BRANCH;
			.to @NxtCol;
ChkRow:		POPY;
			INY;
			CPYI;
			.data VGA_ROWS - 1;
			IF_Y_GE;
			.branchto @ClrLastRow - $;
			BRANCH;
			.to @NxtRow - $;
			// clear last row
ClrLastRow:	MARK2;
			BRANCH;
			.into @GetRowBase - $;
			LDXI;
			.data 0;
			LDAI;
			.data ' ';
ClrRowLoop:	STA, M[Y+X];
			INX;
			CPXI;
			.data VGA_COLS;
			IF_X_GE;
			.branchto @ScrDone - $;
			BRANCH;
			.to @ClrRowLoop - $;
			
// Y = VGA_BASE + row * VGA_COLS
GetRowBase:	LDXI;
			.data VGA_COLS;
			MARK2;
			BRANCH;
			.into @MulU - $;
			ADYI;
			.data VGA_BASE;
ScrDone:	RTS;
			
VGA_CR:		POPA;
			MARK2;
			BRANCH;
			.into @GetCursorXY - $;
			LDXI;
			.data 0;
SetCursorXY:PUSHY;
			LDYI;
			.data CURSOR_X;
			STX, M[Y];	// M[CURSOR_X] <= X
			LDXI;
			.data CURSOR_Y;
			POPY;
			STY, M[X];	// M[CURSOR_Y] <= Y
			RTS;


VGA_LF:		POPA;
			MARK2;
			BRANCH;
			.into @GetCursorXY - $;
			BRANCH;
			.to @NextRow1 - $;

VGA_CLS:	POPA;
			LDAI;
			.data ' ';	// use space character to clear screen
			LDYI;
			.data 0;
RowLoop:	PUSHY;
			ADYI;
			.data VGA_BASE;
			LDXI;
			.data 0;
ColLoop:	STA, M[Y+X];
			INX;
			CPXI;
			.data VGA_COLS;
			IF_X_GE;
			.branchto @NxtRow0 - $;
			BRANCH;
			.to @ColLoop - $;
NxtRow0:	POPY;
			INY;
			CPYI;
			.data VGA_ROWS;
			IF_Y_GE;
			.branchto @VGA_HOME - $;
			BRANCH;
			.to @RowLoop - $;
VGA_HOME:	LDX, LDY, M[IMM];
			.data 0;			// X, Y <= 0
			BRANCH;
			.to @SetCursorXY - $;
					

GetCursorXY:LDYI;
			.data CURSOR_X;
			LDX, M[Y];		// X <= M[CURSOR_X]
			PUSHX;
			LDXI;
			.data CURSOR_Y;
			LDY, M[X];		// Y <= M[CURSOR_Y]
			POPX;
			RTS;	

DisplayAt:	PUSHX;	// save column
			PUSHA;	// save ASCII code
			LDXI;
			.data VGA_COLS;
			MARK2;
			BRANCH;
			.into @MulU - $;	// A.Y <= Y * VGA_COLS
			POPA;
			POPX;
			ADYI;
			.data VGA_BASE;
			STA, M[Y+X];
			RTS;

VGATest:	PUSHA;		// keep A on stack top
			LDYI;
			.data VGA_BASE;
			LDXI;
			.data 0;
VGATLoop:	LDA, X;
			ADC, M[S];	// add base value from A
			STA, M[Y+X];
			INX;
			CPXI;
			.data VGA_COLS * VGA_ROWS;
			IF_X_GE;
			.branchto @VGATestEx - $;
			BRANCH;
			.to @VGATLoop - $;
VGATestEx:	POPA;
			RTS;

// test stack operations
StackTest:	PUSHF;
			PUSHX;
			CPX, M[S];
			IF_XZ; 
			.branchto @ContY - $;
			HALT;	// ERROR!
ContY:		PUSHY;
			CPY, M[S];
			IF_YZ;
			.branchto @ContA - $;
			HALT;	// ERROR!
ContA:		PUSHA;
			LDA, LDY, LDX, M[IMM];
			.data 0;
			POPA;
			POPY;
			POPX;
			POPF;
			RTS;
// end test			
			
			
