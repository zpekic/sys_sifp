ROW_OFFSET	.alias RAM_BASE + 0;	// space to mark first address of up to 61 rows
CURSOR_X	.alias RAM_BASE + 62;
CURSOR_Y	.alias RAM_BASE + 63;

			.org $;

// Initialize display
VGA_Init:	MARK2;
			BRANCH;
			.into @CLC - $;
			LDAI;
			.data VGA_COLS;
			PUSHA;
			LDAI;
			.data VGA_BASE;	// base address is the start of video RAM
			LDXI;
			.data VGA_ROWS;
			LDYI;
			.data ROW_OFFSET;
			STA, M[Y];
RowOffLoop:	LDA, M[Y];		// previous row 
			INY, ADC, M[S];	// add number of columns, point to current row
			DEX, STA, M[Y];
			IF_XZ;
			.branchto @RowOffDone - $;
			BRANCH;
			.to @RowOffLoop - $;
RowOffDone:	POPA;
			LDAI;
			.data CLS;
			// continue with "clear screen"
			//TRACEON;
			
// Display ASCII in A at CURSOR_X, CURSOR_Y
VGA_OutChr: PUSHX;
			PUSHY;
			PUSHA;
			
			XORI;
			.data HOME;
			IF_AZ; 
			.branchto @VGA_HOME - $;
			
			LDA, M[S];
			XORI;
			.data CLS;
			IF_AZ; 
			.branchto @VGA_CLS - $;
			
			MARK2;
			BRANCH;
			.into @GetCursorXY - $;	// get cursor row, col from RAM

			LDA, M[S];
			XORI;
			.data CR;		
			IF_AZ;
			.branchto @VGA_CR - $;

			LDA, M[S];
			XORI;
			.data LF;		
			IF_AZ; 
			.branchto @VGA_LF - $;

//			default "printable" character output
			POPA;
			
VGA_Print:	NOP; 
			PUSHY;
			MARK2;
			BRANCH;
			.into @GetRowBase - $;
			STA, M[Y+X];
			INX, POPY;
			CPXI;
			.data VGA_COLS;
			IF_X_GE;
			.branchto @NextRow - $;
SetCursorXY:PUSHY;
			LDYI;
			.data CURSOR_X;
			STX, M[Y];	// M[CURSOR_X] <= X
			LDXI;
			.data CURSOR_Y;
			POPY;
			STY, M[X];	// M[CURSOR_Y] <= Y
// main exit restores Y and X
			POPY;
			POPX;
			RTS;
			
NextRow:	LDXI;
			.data 0;
NextRow1:	INY;
			CPYI;
			.data VGA_ROWS;
			IF_Y_GE;
			.branchto @ScrollUp - $;
			BRANCH;
			.to @SetCursorXY - $;

ScrollUp:	LDYI;
			.data 0;
NxtRow:		PUSHY; 		// we will need row later
			LDXI;
			.data 0;
			MARK2;
			BRANCH;
			.into @GetRowBase - $;
NxtCol:		PUSHY;		// destination base on stack
			ADYI;		// add to get source base
			.data VGA_COLS;
			LDA, M[Y+X];	// get character from VGA RAM
			POPY;			// destination base
			STA, M[Y+X];	// store character to one row below, same column
			INX;			// next column
			CPXI;
			.data VGA_COLS;
			IF_X_GE;
			.branchto @ChkRow - $;
			BRANCH;
			.to @NxtCol - $;
ChkRow:		POPY;
			INY;
			CPYI;
			.data VGA_ROWS - 1;
			IF_Y_GE;
			.branchto @ClrLastRow - $;
			BRANCH;
			.to @NxtRow - $;
			// clear last row
ClrLastRow:	NOP;
			LDYI;
			.data VGA_ROWS - 1;
			PUSHY;	
			MARK2;
			BRANCH;
			.into @ClearRow - $;
			POPY;		// set cursor position to X = 0, Y = ROWS - 1
			BRANCH;
			.to @SetX0 - $;
				
VGA_CR:		POPA;
SetX0:		LDXI;
			.data 0;
			BRANCH;
			.to @SetCursorXY - $;

VGA_LF:		POPA;
			BRANCH;
			.to @NextRow1 - $;

VGA_CLS:	POPA;
			LDAI;
			.data ' ';	// use space character to clear screen
			LDYI;
			.data 0;
ClrNextRow:	PUSHY; 
			MARK2;
			BRANCH;
			.into @ClearRow - $;
			POPY;
			INY;
			CPYI;
			.data VGA_ROWS;
			IF_Y_GE;
			.branchto @vga_home1 - $;
			BRANCH;
			.to @ClrNextRow - $;
			
ClearRow: 	MARK2;
			BRANCH;
			.into @GetRowBase - $;
			LDAI;
			.data ' ';
			LDXI;
			.data VGA_COLS / 8 - 1; // bar on the left just to save time
ClrRLoop:	STA, M[Y+X];
			IF_XZ;
			.branchto @ClrDone - $;
			DEX, BRANCH;
			.to @ClrRLoop - $;
ClrDone:	RTS;			
			
VGA_HOME:	POPA;
vga_home1:	LDX, LDY, M[IMM];
			.data 0;			// X, Y <= 0
			BRANCH;
			.to @SetCursorXY - $;
					
GetCursorXY:LDYI;
			.data CURSOR_X;
			LDX, M[Y];		// X <= M[CURSOR_X]
			PUSHX;
			LDXI;
			.data CURSOR_Y;
			LDY, M[X];		// Y <= M[CURSOR_Y]
			POPX;
			RTS;	

GetRowBase:	PUSHA;
			ADYI;
			.data ROW_OFFSET;
			LDA, M[Y];		// row start address in VGA memory
			LDY, A;			// to Y as index base
			POPA;
			RTS;
			
VGA_OutStr:	LDA, M[X];
			IF_AZ;
			.branchto @OutStrDone - $;
			MARK2;
			BRANCH;
			.into @VGA_OutChr - $;
			INX, BRANCH;
			.to @VGA_OutStr - $;
OutStrDone:	RTS;

VGATest:	PUSHA;		// keep A on stack top
			LDYI;
			.data VGA_BASE;
			LDXI;
			.data 0;
VGATLoop:	LDA, X;
			ADC, M[S];	// add base value from A
			STA, M[Y+X];
			INX;
			CPXI;
			.data VGA_COLS * VGA_ROWS;
			IF_X_GE;
			.branchto @VGATestEx - $;
			BRANCH;
			.to @VGATLoop - $;
VGATestEx:	POPA;
			RTS;

		
			
			
