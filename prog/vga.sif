CURSOR_X	.alias RAM_BASE + 0;
CURSOR_Y	.alias RAM_BASE + 1;

// Display ASCII in A at row Y, column X	
			.org $;

// Print string pointed by X to VGA			
Str2VGA:	NOP;
			STY, M[PUSH];	// save Y

Str2VGALoop:LDA, M[X];
			IF_AZ;
			.branchto @Str2VGAExit - $;
			XORI;
			.data CR;		// is it clear screen?
			IF_AZ;
			.branchto @CarReturn - $;

			LDA, M[X];
			XORI;
			.data LF;		
			IF_AZ; 
			.branchto @LineFeed - $;

			LDA, M[X];
			XORI;
			.data HOME;
			IF_AZ; 
			.branchto @Cur2Home - $;
			
			LDA, M[X];
			XORI;
			.data CLS;
			IF_AZ; 
			.branchto @ClrScreen - $;
			
//			default output
			PUSHX;		// save character pointer
			MARK2;
			BRANCH;
			.to @GetCursorXY - $;	// get cursor row, col from RAM
			MARK2;
			BRANCH;
			.into @DisplayAt - $;
			INX;
			CPXI;
			.data VGA_COLS;
			IF_X_GE;
			.branchto @NextRow - $;
NoScroll:	MARK2;
			BRANCH;
			.into @SetCursorXY - $;
// 			next character in the string
NextChar:	POPX;		// restore character pointer
			INX, BRANCH;
			.to @Str2VGALoop - $;
			
NextRow:	LDXI;
			.data 0;
NextRow1:	INY;
			CPYI;
			.data VGA_ROWS;
			IF_Y_GE;
			.branchto @ScrollUp - $;
			BRANCH;
			.to @NoScroll - $;

ScrollUp:	NOP;
			LDYI;
			.data 0;
NxtRow:		PUSHY; 		// we will need row later
			LDXI;
			.data 0;
NxtCol:		PUSHX;		// we will need column later
			MARK2;
			BRANCH;
			.into @GetRowBase - $;
			PUSHY;		// destination base on stack
			ADYI;		// add to get source base
			.data VGA_ROWS;
			LDA, M[Y+X];	// get character from VGA RAM
			POPY;			// destination base
			STA, M[Y+X];	// store character to one row below, same column
			INX;			// next column
			CPXI;
			.data VGA_COLS;
			IF_X_GE;
			.branchto @ChkRow - $;
			BRANCH;
			.to @NxtCol;
ChkRow:		POPY;
			INY;
			CPYI;
			.data VGA_ROWS - 1;
			IF_Y_GE;
			.branchto @ClrLastRow - $;
			BRANCH;
			.to @NxtRow - $;
			// clear last row
ClrLastRow:	MARK2;
			BRANCH;
			.into @GetRowBase - $;
			LDXI;
			.data 0;
			LDAI;
			.data ' ';
ClrRowLoop:	STA, M[Y+X];
			INX;
			CPXI;
			.data VGA_COLS;
			IF_X_GE;
			.branchto @ScrDone - $;
			BRANCH;
			.to @ClrRowLoop - $;
			
// Y = VGA_BASE + row * VGA_COLS
GetRowBase:	LDXI;
			.data VGA_COLS;
			MARK2;
			BRANCH;
			.into @MulU - $;
			ADYI;
			.data VGA_BASE;
ScrDone:	RTS;
			
CarReturn:	MARK2;
			BRANCH;
			.into @GetCursorXY - $;
			LDXI;
			.data 0;
			BRANCH;
			.to @NoScroll - $;

LineFeed:	MARK2;
			BRANCH;
			.into @GetCursorXY - $;
			BRANCH;
			.to @NextRow1 - $;

ClrScreen:	LDXI;
			.data VGA_COLS;
			LDYI;
			.data VGA_ROWS;
			MARK2;
			BRANCH;
			.into @MulU - $;
			LDXI;
			.data VGA_BASE;
			LDAI;
			.data ' ';	// use space character to clear screen
ClrPos:		DEY;
			STA, M[Y+X];
			IF_YZ;
			.branchto @ClrPos - $;
			STA, M[Y+X];
Cur2Home:	LDX, LDY, M[IMM];
			.data 0;			// X, Y <= 0
			BRANCH;
			.to @NoScroll - $;
			
Str2VGAExit:POPY;	// restore Y
			RTS;
			
SetCursorXY:PUSHA;
			PUSHY;
			LDYI;
			.data CURSOR_X;
			STX, M[Y];	// M[CURSOR_X] <= X
			INY, POPA;
			STA, M[Y];	// M[CURSOR_Y] <= Y
			POPA;
			RTS;

GetCursorXY:PUSHA;
			LDYI;
			.data CURSOR_X;
			LDX, M[Y];		// X <= M[CURSOR_X]
			INY;
			LDA, M[Y];
			PUSHA;
			POPY;			// Y <= M[CURSOR_Y]
			POPA;
			RTS;	

DisplayAt:	PUSHX;	// save column
			PUSHA;	// save ASCII code
			LDXI;
			.data VGA_COLS;
			MARK2;
			BRANCH;
			.into @MulU - $;	// A.Y <= Y * VGA_COLS
			POPA;
			POPX;
			ADYI;
			.data VGA_BASE;
			STA, M[Y+X];
			RTS;

QTest:		PUSHY;
			LDYI;
			.data VGA_BASE;
			LDXI;
			.data 0;
QTestLoop:	LDA, X;
			STA, M[Y+X];
			INX;
			CPXI;
			.data VGA_COLS * VGA_ROWS;
			IF_XZ;
			.branchto @Str2VGAExit - $;
			BRANCH;
			.to @QTestLoop - $;
			
