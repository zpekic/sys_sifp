ROW_OFFSET	.alias RAM_BASE + 0;	// space to mark first address of up to 61 rows
CURSOR_X	.alias RAM_BASE + 62;
CURSOR_Y	.alias RAM_BASE + 63;

			.org $;

// Initialize display
VGA_Init:	MARK2;
			BRANCH;
			.into @CLC - $;
			LDAI;
			.data VGA_COLS;
			PUSHA;
			LDXI;
			.data VGA_ROWS;
			LDYI;
			.data ROW_OFFSET;
			LDAI;
			.data 0;
			STA, M[Y];
RowOffLoop:	LDA, M[Y];		// previous row 
			INY, ADC, M[S];	// add number of columns, point to current row
			DEX, STA, M[Y];
			IF_XZ;
			.branchto @RowOffDone - $;
			BRANCH;
			.to @RowOffLoop - $;
RowOffDone:	POPA;
			LDAI;
			.data CLS;
			// continue with "clear screen"
			
// Display ASCII in A at row Y, column X	
VGA_OutChr: PUSHA;
			
			XORI;
			.data HOME;
			IF_AZ; 
			.branchto @VGA_HOME - $;
			
			LDA, M[S];
			XORI;
			.data CLS;
			IF_AZ; 
			.branchto @VGA_CLS - $;

			
			MARK2;
			BRANCH;
			.into @GetCursorXY - $;	// get cursor row, col from RAM

			LDA, M[S];
			XORI;
			.data CR;		
			IF_AZ;
			.branchto @VGA_CR - $;

			LDA, M[S];
			XORI;
			.data LF;		
			IF_AZ; 
			.branchto @VGA_LF - $;

//			default "printable" character output
			LDA, M[S];
			MARK2;
			BRANCH;
			.into @DisplayAt - $;
			INX;
			CPXI;
			.data VGA_COLS;
			IF_X_GE;
			.branchto @NextRow - $;
			BRANCH;
			.to @SetCursorXY - $;
			
NextRow:	LDXI;
			.data 0;
NextRow1:	INY;
			CPYI;
			.data VGA_ROWS;
			IF_Y_GE;
			.branchto @ScrollUp - $;
			BRANCH;
			.to @SetCursorXY - $;

ScrollUp:	NOP;
			LDYI;
			.data 0;
NxtRow:		PUSHY; 		// we will need row later
			LDXI;
			.data 0;
NxtCol:		PUSHX;		// we will need column later
			MARK2;
			BRANCH;
			.into @GetRowBase - $;
			PUSHY;		// destination base on stack
			ADYI;		// add to get source base
			.data VGA_ROWS;
			LDA, M[Y+X];	// get character from VGA RAM
			POPY;			// destination base
			STA, M[Y+X];	// store character to one row below, same column
			INX;			// next column
			CPXI;
			.data VGA_COLS;
			IF_X_GE;
			.branchto @ChkRow - $;
			BRANCH;
			.to @NxtCol;
ChkRow:		POPY;
			INY;
			CPYI;
			.data VGA_ROWS - 1;
			IF_Y_GE;
			.branchto @ClrLastRow - $;
			BRANCH;
			.to @NxtRow - $;
			// clear last row
ClrLastRow:	MARK2;
			BRANCH;
			.into @GetRowBase - $;		// row start address in VGA memory
			LDXI;
			.data 0;
			LDAI;
			.data ' ';
ClrRowLoop:	STA, M[Y+X];
			INX;
			CPXI;
			.data VGA_COLS;
			IF_X_GE;
			.branchto @ScrDone - $;
			BRANCH;
			.to @ClrRowLoop - $;
				
VGA_CR:		POPA;
			LDXI;
			.data 0;
SetCursorXY:PUSHY;
			LDYI;
			.data CURSOR_X;
			STX, M[Y];	// M[CURSOR_X] <= X
			LDXI;
			.data CURSOR_Y;
			POPY;
			STY, M[X];	// M[CURSOR_Y] <= Y
ScrDone:	RTS;

VGA_LF:		POPA;
			BRANCH;
			.to @NextRow1 - $;

VGA_CLS:	POPA;
			LDAI;
			.data ' ';	// use space character to clear screen
			LDYI;
			.data 0;
ClrNextRow:	MARK2;
			BRANCH;
			.into @GetRowBase - $;
			MARK2;
			BRANCH;
			.into @ClearRow - $;
			INY;
			CPYI;
			.data VGA_ROWS;
			IF_Y_GE;
			.branchto @ScrDone - $;
			BRANCH;
			.to @ClrNextRow - $;
			
ClearRow: 	MARK2;
			BRANCH;
			.into @GetRowBase - $;
			LDXI;
			.data VGA_COLS - 1;
ClrRLoop:	STA, M[Y+X];
			IF_XZ;
			.branchto @ScrDone - $;
			DEX, BRANCH;
			.to @ClrRLoop - $;
			
VGA_HOME:	LDX, LDY, M[IMM];
			.data 0;			// X, Y <= 0
			BRANCH;
			.to @SetCursorXY - $;
					
GetCursorXY:LDYI;
			.data CURSOR_X;
			LDX, M[Y];		// X <= M[CURSOR_X]
			PUSHX;
			LDXI;
			.data CURSOR_Y;
			LDY, M[X];		// Y <= M[CURSOR_Y]
			POPX;
			RTS;	

GetRowBase:	PUSHA;
			ADYI;
			.data ROW_OFFSET;
			LDA, M[Y];		// row start address in VGA memory
			LDY, A;			// to Y as index base
			POPA;
			RTS;
			
DisplayAt:	MARK2;
			BRANCH;
			.into @GetRowBase - $;
			STA, M[Y+X];
			RTS;

VGATest:	PUSHA;		// keep A on stack top
			LDYI;
			.data VGA_BASE;
			LDXI;
			.data 0;
VGATLoop:	LDA, X;
			ADC, M[S];	// add base value from A
			STA, M[Y+X];
			INX;
			CPXI;
			.data VGA_COLS * VGA_ROWS;
			IF_X_GE;
			.branchto @VGATestEx - $;
			BRANCH;
			.to @VGATLoop - $;
VGATestEx:	POPA;
			RTS;

// test stack operations
StackTest:	PUSHF;
			PUSHX;
			CPX, M[S];
			IF_XZ; 
			.branchto @ContY - $;
			HALT;	// ERROR!
ContY:		PUSHY;
			CPY, M[S];
			IF_YZ;
			.branchto @ContA - $;
			HALT;	// ERROR!
ContA:		PUSHA;
			LDA, LDY, LDX, M[IMM];
			.data 0;
			POPA;
			POPY;
			POPX;
			POPF;
			RTS;
// end test			
			
			
